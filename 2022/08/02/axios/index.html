
<!DOCTYPE html>
<html lang="zh-CN" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>axios - coderBlog</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="referrer" content="no-referrer" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="axios的封装---mbw的博客,"> 
    <meta name="description" content="前端个人博客,一、axios的基本使用
第一步：安装axios npm install axios
第二步：新建一个axios文件 这里我建到service中 命名为axios_demo.ts
第三步：在此文件中,"> 
    <meta name="author" content="Ma"> 
    <link rel="alternative" href="atom.xml" title="coderBlog" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

    
    
    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:title" content="axios - coderBlog"/>
    <meta name="twitter:description" content="前端个人博客,一、axios的基本使用
第一步：安装axios npm install axios
第二步：新建一个axios文件 这里我建到service中 命名为axios_demo.ts
第三步：在此文件中,"/>
    
    
    
    
    <meta property="og:site_name" content="coderBlog"/>
    <meta property="og:type" content="object"/>
    <meta property="og:title" content="axios - coderBlog"/>
    <meta property="og:description" content="前端个人博客,一、axios的基本使用
第一步：安装axios npm install axios
第二步：新建一个axios文件 这里我建到service中 命名为axios_demo.ts
第三步：在此文件中,"/>
    
<link rel="stylesheet" href="/css/diaspora.css">

    <script>window.searchDbPath = "/search.xml";</script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
<meta name="generator" content="Hexo 6.2.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">coderBlog</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://example.com"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">axios</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">axios</h1>
        <div class="stuff">
            <span>八月 02, 2022</span>
            

        </div>
        <div class="content markdown">
            <h1 id="一、axios的基本使用"><a href="#一、axios的基本使用" class="headerlink" title="一、axios的基本使用"></a>一、axios的基本使用</h1><ul>
<li>第一步：安装axios npm install axios</li>
<li>第二步：新建一个axios文件 这里我建到service中 命名为axios_demo.ts</li>
<li>第三步：在此文件中引入axios import axios from ‘axios’</li>
<li>第四步：在main.ts中引入此文件 import ‘.&#x2F;service&#x2F;axios_demo’</li>
</ul>
<h1 id="二、axios全局的配置选项"><a href="#二、axios全局的配置选项" class="headerlink" title="二、axios全局的配置选项"></a>二、axios全局的配置选项</h1><h2 id="1、配置默认url：例子："><a href="#1、配置默认url：例子：" class="headerlink" title="1、配置默认url：例子："></a>1、配置默认url：例子：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">axios.default.baseURL = &#x27;http://httpbin.org&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2、配置超时时间："><a href="#2、配置超时时间：" class="headerlink" title="2、配置超时时间："></a>2、配置超时时间：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">axios.default.timeout = 10000</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="3、配置headers："><a href="#3、配置headers：" class="headerlink" title="3、配置headers："></a>3、配置headers：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">axios.default.header= &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="三、axios针对每一个请求单独的配置选项"><a href="#三、axios针对每一个请求单独的配置选项" class="headerlink" title="三、axios针对每一个请求单独的配置选项"></a>三、axios针对每一个请求单独的配置选项</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">axios.get(&#x27;/get&#x27;,&#123;</span><br><span class="line">    params:&#123;</span><br><span class="line">        name:&#x27;coderwhy&#x27;,</span><br><span class="line">        age:18</span><br><span class="line">    &#125;// 参数</span><br><span class="line">    timeout:5000,// 超时时间</span><br><span class="line">    header:&#123;&#125;,// 配置header</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="四、axios-all"><a href="#四、axios-all" class="headerlink" title="四、axios.all"></a>四、axios.all</h1><h2 id="多个请求一起返回，本质上是promise-all"><a href="#多个请求一起返回，本质上是promise-all" class="headerlink" title="多个请求一起返回，本质上是promise.all"></a>多个请求一起返回，本质上是promise.all</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">axios.all([</span><br><span class="line">    axios.get(&#x27;/get&#x27;,&#123;params: &#123;name: &#x27;mmm&#x27;,age: &#x27;22&#x27;&#125; &#125;),</span><br><span class="line">    axios.post(&#x27;/post&#x27;,&#123;data: &#123;name: &#x27;mmm&#x27;,age: &#x27;22&#x27;&#125; &#125;),</span><br><span class="line">])</span><br><span class="line">.then(&#123;res&#125; =&gt; &#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="上述请求的返回值res是一个数组-数组中包含了第一个请求的结果和第二个请求的结果-两个结果拿到的都是AxiosResponse类型"><a href="#上述请求的返回值res是一个数组-数组中包含了第一个请求的结果和第二个请求的结果-两个结果拿到的都是AxiosResponse类型" class="headerlink" title="上述请求的返回值res是一个数组 数组中包含了第一个请求的结果和第二个请求的结果 两个结果拿到的都是AxiosResponse类型"></a>上述请求的返回值res是一个数组 数组中包含了第一个请求的结果和第二个请求的结果 两个结果拿到的都是AxiosResponse类型</h2><h1 id="五、axios拦截器"><a href="#五、axios拦截器" class="headerlink" title="五、axios拦截器"></a>五、axios拦截器</h1><p><strong>在实际开发中 可能遇到以下情况</strong><br><strong>当你向服务器端发送请求时 需要给每个请求携带上token 将token放到请求头里</strong><br><strong>请求时间比较长，在请求过程当中在界面上显示loading的提示，等到请求结束时把loading移除掉，这里我们就需要把loading先放到界面上，等待请求完毕再把loading移除</strong><br><strong>种种情况都说明我们经常需要把请求拦截下来 做一些事情</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// interceptors 拦截器</span><br><span class="line">// axios.interceptors.request拦截请求</span><br><span class="line">// axios.interceptors.response拦截响应</span><br><span class="line">// axios.interceptors.request.use(fn1,fn2)</span><br><span class="line">// fn1代表请求发送成功会执行的函数 fn2表示请求发送失败时会执行的函数</span><br><span class="line"></span><br><span class="line">axios.interceptors.request.use((config) =&gt; &#123;</span><br><span class="line">    // 这里的config是上述的一些配置 例如给请求添加token 做loading的动画</span><br><span class="line">    console.log(&quot;请求成功的拦截&quot;)</span><br><span class="line">    return config //用完后要将这个config返回出去</span><br><span class="line">&#125;,(err) =&gt; &#123;</span><br><span class="line">    console.log(&quot;请求发生错误&quot;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// axios.interceptors.response.use(fn1,fn2)</span><br><span class="line">// fn1: 服务器相应成功(服务器正常返回了数据 状态码：20x)</span><br><span class="line"></span><br><span class="line">axios.interceptors.response.use((res) =&gt; &#123;</span><br><span class="line">    return res</span><br><span class="line">&#125;,(err) =&gt; &#123;</span><br><span class="line">    console.log(&#x27;服务器相应失败&#x27;)</span><br><span class="line">    return err</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="六、axios的封装"><a href="#六、axios的封装" class="headerlink" title="六、axios的封装"></a>六、axios的封装</h1><h3 id="配置："><a href="#配置：" class="headerlink" title="配置："></a>配置：</h3><ul>
<li>第一步：在service下创建文件 index.js 作为统一的出口</li>
<li>第二步：export default mRequest &#x3D; {} 加m前缀是为了防止命名冲突</li>
<li>第三步：在request(service下属文件夹)文件夹中新建index.ts</li>
<li>第四步：在此文件中创建一个类 class MRequest{}</li>
<li>第五步：导出这个类 export default MRequest &#x3D; {}</li>
<li>第六步：在service的index.ts中导入这个类impor MRequest from ‘.&#x2F;request’</li>
<li>第七步：导出：export default new MRequest() 或者 const mRequest &#x3D; new MRequest 然后export default mRequest</li>
<li>第八步：在main.ts中导入 import mRequest from ‘.&#x2F;service’ 因为是index.ts默认接口所以可以不写</li>
</ul>
<h3 id="封装函数"><a href="#封装函数" class="headerlink" title="封装函数"></a>封装函数</h3><ul>
<li>在service&#x2F;request&#x2F;index.ts 中的class MRequest 类中封装函数 这里封装好的函数可以在别的地方通过.函数名的方式调用</li>
<li>为了让创建出来的实例没人任何干扰 例子：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const mRequest=new MRequest(&#123;</span><br><span class="line">    baseURL:&#x27;地址一&#x27;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const mRequest2=new MRequest(&#123;</span><br><span class="line">    baseURL:&#x27;地址二&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
解决方案：<br>在 MRequest类中这么写：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class MRequest&#123;</span><br><span class="line">    instance: any</span><br><span class="line"></span><br><span class="line">    constructar(config: any) &#123;</span><br><span class="line">        this.instance=axios.create(config)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
因为每次new一个实例的时候都会触发构造器 我们将参数接受过来后改变instance变量 不会让他们参生任何影响<br>这里的 instance需要一个确切的类型 axios给了我们一个确切的类型<br>首先我们需要引入 import type { AxiosInstance } from ‘axios’<br>这个类型是axios给我们封装好的 所以我们完整的代码应该这么写<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class MRequest&#123;</span><br><span class="line">    instance: AxiosInstance</span><br><span class="line"></span><br><span class="line">    constructar(config: AxiosRequestConfig) &#123;</span><br><span class="line">        this.instance=axios.create(config)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这里的config是AxiosRequestConfig类型 也是axios封装好的 里面有一些可选参数<br><img src="https://s1.doveoss.com/i/2022/08/04/11647qn.png" alt="alt AxiosRequestConfig类型的可选参数"><br>这样我们在实例传入对应的参数都有提示<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const mRequest = new MRequest(&#123;</span><br><span class="line">  baseURL: &#x27;&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
这里的baseURL我们不要写死 可以写到config.ts里 这样可以自动区分 开发环境 生产环境和测试环境<br>这里我们封装了两个参数 需要更多参数可以来这里加<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let BASE_URL = &#x27;&#x27;</span><br><span class="line">const TIME_OUT = 10000</span><br><span class="line"></span><br><span class="line">if (process.env.NODE_ENV === &#x27;development&#x27;) &#123;</span><br><span class="line">  BASE_URL = &#x27;http://123.207.32.32:8000/&#x27;</span><br><span class="line">&#125; else if (process.env.NODE_ENV === &#x27;production&#x27;) &#123;</span><br><span class="line">  BASE_URL = &#x27; &#x27;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  BASE_URL = &#x27; &#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export &#123; BASE_URL, TIME_OUT &#125;</span><br></pre></td></tr></table></figure>
在service的index.ts中引入并使用<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import MRequest from &#x27;./request&#x27;</span><br><span class="line">import &#123; BASE_URL, TIME_OUT &#125; from &#x27;./request/config&#x27;</span><br><span class="line">const mRequest = new MRequest(&#123;</span><br><span class="line">  baseURL: BASE_URL,</span><br><span class="line">  timeout: TIME_OUT</span><br><span class="line">&#125;)</span><br><span class="line">export default mRequest</span><br><span class="line"></span><br></pre></td></tr></table></figure>
接下来 我们可以尝试一下封装一个request函数<br>首先 在 MRequest类中创建一个request函数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class MRequest &#123;</span><br><span class="line">  instance: AxiosInstance</span><br><span class="line">  constructor(config: AxiosRequestConfig) &#123;</span><br><span class="line">    this.instance = axios.create(config)</span><br><span class="line">  &#125;</span><br><span class="line">  request(config: AxiosRequestConfig): void &#123;</span><br><span class="line">    this.instance.request(config).then((res) =&gt; &#123;</span><br><span class="line">      console.log(res)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这里的config也是AxiosRequestConfig类型<br>这样 我们就简单的实现了一个request函数啦<br>接下来让我们去main.ts文件中使用一下吧<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createApp &#125; from &#x27;vue&#x27;</span><br><span class="line">import App from &#x27;./App.vue&#x27;</span><br><span class="line">import router from &#x27;./router&#x27;</span><br><span class="line">import store from &#x27;./store&#x27;</span><br><span class="line">// 引入一下</span><br><span class="line">import mRquest from &#x27;./service&#x27;</span><br><span class="line">// import &#x27;./service/axios_demo&#x27;</span><br><span class="line"></span><br><span class="line">// 在这里调用request函数</span><br><span class="line">mRquest.request(&#123;</span><br><span class="line">  url: &#x27;/home/multidata&#x27;,</span><br><span class="line">  method: &#x27;GET&#x27;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">createApp(App).use(store).use(router).mount(&#x27;#app&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
运行结果：<br><img src="https://s1.doveoss.com/i/2022/08/04/12f2sxw.png" alt="alt AxiosRequestConfig类型的可选参数"></li>
</ul>
<p><strong>小总结：简单来说，首先新建service下的index.ts文件 该文件用来实例一个或多个封装好的axios对象并导出。其次在service下新建request文件夹，新建index.ts和config.ts文件，分别用来做axios封装的具体实现和自动区分运行环境的配置文件</strong></p>
<h2 id="关于拦截器的封装"><a href="#关于拦截器的封装" class="headerlink" title="关于拦截器的封装"></a>关于拦截器的封装</h2><ul>
<li>我们要对拦截器进行封装 以达到一种使用效果 当我们在实例化对象时，不仅仅可以传入baseURL和timeout，还可以传入拦截器的配置 如下：<br><img src="https://s2.doveoss.com/i/2022/08/05/sw4npg.png" alt="alt 拦截器封装使用1"></li>
</ul>
<p><strong>那么我们就需要对我们的类做一下改动，让他支持interceptors</strong></p>
<ul>
<li>首先 我们需要新建一个接口继承自 AxiosRequestConfig<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface MRequestConfig extends AxiosRequestConfig &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>然后将类中构造器参数config原本的类型换成 MRequestConfig<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">constructor(config: MRequestConfig) &#123;</span><br><span class="line">    this.instance = axios.create(config)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li>此时 我们可以对MRquestConfig接口进行扩展 里面需要一个intercepiors属性 用来接收我们在实例中写的拦截器配置,但是该属性也需要一个类型 这个类型就是我们在实例中进行配置时，可能需要的参数，根据axios拦截器的特点我们将类型设置成如下接口<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface MRequestInterceptors &#123;</span><br><span class="line">  requestInterceptor?: (config: AxiosRequestConfig) =&gt; AxiosRequestConfig</span><br><span class="line">  requestInterceptorCatch?: (error: any) =&gt; any</span><br><span class="line">  responseInterceptor?: (res: AxiosResponse) =&gt; AxiosResponse</span><br><span class="line">  responseInterceptorCatch?: (error: any) =&gt; any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>接口写好后 就可以对MRquestConfig进行扩展了<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface MRequestConfig extends AxiosRequestConfig &#123;</span><br><span class="line">  intercepiors?: MRequestInterceptors</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>这样 我们就可以往构造器中传入我们对拦截器的配置了 接下来我们对传过来的配置进行保存<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class MRequest &#123;</span><br><span class="line">  instance: AxiosInstance</span><br><span class="line">  interceptors?: MRequestInterceptors</span><br><span class="line">  constructor(config: MRequestConfig) &#123;</span><br><span class="line">    this.instance = axios.create(config)</span><br><span class="line">    this.interceptors = config.intercepiors</span><br><span class="line">  &#125;</span><br><span class="line">  request(config: AxiosRequestConfig): void &#123;</span><br><span class="line">    this.instance.request(config).then((res) =&gt; &#123;</span><br><span class="line">      console.log(res)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li>这样 我们传过来的配置就会保存到interceptors中 我们可以在构造器中对该配置做一些操作<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">constructor(config: MRequestConfig) &#123;</span><br><span class="line">   this.instance = axios.create(config)</span><br><span class="line">   this.interceptors = config.intercepiors</span><br><span class="line">   // 请求拦截器</span><br><span class="line">   this.instance.interceptors.request.use(</span><br><span class="line">     this.interceptors?.requestInterceptor,</span><br><span class="line">     this.interceptors?.requestInterceptorCatch</span><br><span class="line">   )</span><br><span class="line">   // 相应拦截器</span><br><span class="line">   this.instance.interceptors.response.use(</span><br><span class="line">     this.interceptors?.responseInterceptor,</span><br><span class="line">     this.interceptors?.responseInterceptorCatch</span><br><span class="line">   )</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li>这样 就封装好了一个拦截器 接下来就可以去实例里面试一下了<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const mRequest = new MRequest(&#123;</span><br><span class="line">  baseURL: BASE_URL,</span><br><span class="line">  timeout: TIME_OUT,</span><br><span class="line">  intercepiors: &#123;</span><br><span class="line">    requestInterceptor: (config) =&gt; &#123;</span><br><span class="line">      console.log(&#x27;请求拦截成功&#x27;)</span><br><span class="line">      console.log(config)</span><br><span class="line">      return config</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
运行结果<br><img src="https://s1.doveoss.com/i/2022/08/05/z9xnt7.png" alt="alt 拦截器封装使用的运行结果"></li>
</ul>
<h2 id="继续添加拦截器-所有的实例都会有的拦截器"><a href="#继续添加拦截器-所有的实例都会有的拦截器" class="headerlink" title="继续添加拦截器 所有的实例都会有的拦截器"></a>继续添加拦截器 所有的实例都会有的拦截器</h2><ul>
<li>首先在类的实例中添加两个拦截器 意味着我每一个实例 都会给这个实例添加拦截器<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">constructor(config: MRequestConfig) &#123;</span><br><span class="line">    this.instance = axios.create(config)</span><br><span class="line">    this.interceptors = config.intercepiors</span><br><span class="line">    this.instance.interceptors.request.use(</span><br><span class="line">      this.interceptors?.requestInterceptor,</span><br><span class="line">      this.interceptors?.requestInterceptorCatch</span><br><span class="line">    )</span><br><span class="line">    this.instance.interceptors.response.use(</span><br><span class="line">      this.interceptors?.responseInterceptor,</span><br><span class="line">      this.interceptors?.responseInterceptorCatch</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    this.instance.interceptors.request.use(</span><br><span class="line">      (config) =&gt; &#123;</span><br><span class="line">        return config</span><br><span class="line">      &#125;,</span><br><span class="line">      (err) =&gt; &#123;</span><br><span class="line">        return err</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">    this.instance.interceptors.response.use(</span><br><span class="line">      (res) =&gt; &#123;</span><br><span class="line">        return res</span><br><span class="line">      &#125;,</span><br><span class="line">      (err) =&gt; &#123;</span><br><span class="line">        return err</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li>此时 不管哪一个实例的对象都可以触发这两个拦截器了</li>
</ul>
<h3 id="如果想要对实例后的每一个请求都对拦截的控制-需要以下封装"><a href="#如果想要对实例后的每一个请求都对拦截的控制-需要以下封装" class="headerlink" title="如果想要对实例后的每一个请求都对拦截的控制 需要以下封装"></a>如果想要对实例后的每一个请求都对拦截的控制 需要以下封装</h3><ul>
<li>第一步 把request函数中的 cofig类型改为前面定义好的MRequestConfig 这样做是方便每个请求传自己的拦截器配置</li>
<li>第二步 其实config里面是有这两个封装好的方法 这里我们可以利用这两个方法 对我们的数据做一些事情<br><img src="https://s1.doveoss.com/i/2022/08/06/ugs8he.png" alt="alt 拦截器封装使用的运行结果"></li>
<li>第三步 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">request(config: MRequestConfig): void &#123;</span><br><span class="line">   if (config.intercepiors?.requestInterceptor) &#123;</span><br><span class="line">     config = config.intercepiors?.requestInterceptor(config)</span><br><span class="line">   &#125;</span><br><span class="line">   this.instance.request(config).then((res) =&gt; &#123;</span><br><span class="line">     if (config.intercepiors?.responseInterceptor) &#123;</span><br><span class="line">       res = config.intercepiors?.responseInterceptor(res)</span><br><span class="line">     &#125;</span><br><span class="line">     console.log(res)</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<strong>这里我解释一下这段代码 首先这个函数的位置是在类里面但是不在构造器里 因为这个函数是给请求对象用的，而不是给某个实例用的 其次这里先做一下if判断是为了看一下这个请求对象是否有传入一个拦截器的选项 假若这个请求对象没有传入一个拦截器 那么就不需要进行下面的操作 接下来 这里重新赋值了一下config 原因是在我们请求对象中，我们requestInterceptor(config)其实是一个函数 这个函数运行完成后 会把新的config返回出来 这中间可能会对config做一些操作 我们只需要在这里执行一下这个函数 就可以把新的config拿到 这种情况下一般不会处理err</strong></li>
</ul>
<h2 id="关于loading页面与拦截器的配合使用"><a href="#关于loading页面与拦截器的配合使用" class="headerlink" title="关于loading页面与拦截器的配合使用"></a>关于loading页面与拦截器的配合使用</h2><ul>
<li>首先我们这里的loading页面时引用了element plus这个ui库</li>
<li>我们先引入这个组件和css文件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123; ElLoading &#125; from &#x27;element-plus/lib/index&#x27;</span><br><span class="line">import &#x27;element-plus/theme-chalk/index.css&#x27;</span><br></pre></td></tr></table></figure></li>
<li>接下来扩充一下MRequest类的构造函数的参数config的类型MRequestConfig</li>
<li>新增类型 showLoading<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export interface MRequestConfig extends AxiosRequestConfig &#123;</span><br><span class="line">  intercepiors?: MRequestInterceptors</span><br><span class="line">  showLoading?: boolean</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
目的是为了让实例决定这个请求是否需要loading界面 如果需要就传showLoading：true</li>
<li>接下来改写拦截器<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">this.instance.interceptors.request.use(</span><br><span class="line">      (config) =&gt; &#123;</span><br><span class="line">        console.log(&#x27;请求拦截成功23232&#x27;)</span><br><span class="line">        if (this.showLoading) &#123;</span><br><span class="line">          this.loadingInstance1 = ElLoading.service(&#123;</span><br><span class="line">            lock: true,</span><br><span class="line">            text: &#x27;loading...&#x27;,</span><br><span class="line">            background: &#x27;rgba(0, 0, 0, 0.5)&#x27;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return config</span><br><span class="line">      &#125;,</span><br><span class="line">      (err) =&gt; &#123;</span><br><span class="line">        // 将loading移除</span><br><span class="line">        if (this.showLoading) &#123;</span><br><span class="line">          this.loadingInstance1.close()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return err</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">    this.instance.interceptors.response.use(</span><br><span class="line">      (res) =&gt; &#123;</span><br><span class="line">        console.log(&#x27;响应拦截成功1&#x27;)</span><br><span class="line">        // 将loading移除</span><br><span class="line">        if (this.showLoading) &#123;</span><br><span class="line">          this.loadingInstance1.close()</span><br><span class="line">        &#125;</span><br><span class="line">        return res</span><br><span class="line">      &#125;,</span><br><span class="line">      (err) =&gt; &#123;</span><br><span class="line">        if (this.showLoading) &#123;</span><br><span class="line">          this.loadingInstance1.close()</span><br><span class="line">        &#125;</span><br><span class="line">        return err</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
这里我们直接在类的全局拦截器里改写 适用于所有的实例请求</li>
</ul>
<p>-接下来就可以传入值了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const mRequest = new MRequest(&#123;</span><br><span class="line">  baseURL: BASE_URL,</span><br><span class="line">  timeout: TIME_OUT,</span><br><span class="line">  // 这里传入true就代表需要loading界面</span><br><span class="line">  showLoading: true,</span><br><span class="line">  //</span><br><span class="line">  intercepiors: &#123;</span><br><span class="line">    requestInterceptor: (config) =&gt; &#123;</span><br><span class="line">      console.log(&#x27;请求拦截成功&#x27;)</span><br><span class="line">      console.log(config)</span><br><span class="line">      return config</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.doveoss.com/i/2022/08/07/yy1z43.png" alt="alt 拦截器封装使用的运行结果"></p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title="0" data-url="https://link.hhtjim.com/163/442869203.mp3"></li>
                        
                    
                        
                            <li title="1" data-url="https://link.hhtjim.com/163/441491828.mp3"></li>
                        
                    
                        
                            <li title="2" data-url="https://link.hhtjim.com/163/442869203.mp3"></li>
                        
                    
                </ul>
            
        </div>
        
        
    <div id="gitalk-container" class="comment link"
		data-enable="true"
        data-ae="false"
        data-ci=""
        data-cs=""
        data-r=""
        data-o=""
        data-a=""
        data-d="false"
    >查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>

<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
